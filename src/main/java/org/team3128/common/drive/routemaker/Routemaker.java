package org.team3128.common.drive.routemaker;

import org.team3128.common.drive.Odometer;
import org.team3128.common.drive.SRXTankDrive;
import org.team3128.common.util.Convert;
import org.team3128.common.util.RobotMath;
import org.team3128.common.util.units.Length;


/**
 * Main class for the routemaker system. Generates entire trajectories and creates the series of
 * motion profile points to follow a trajectory.
 * 
 * Okay, so I have some explaining to do. Basically, this system handles the generation of aunomtous
 * routes by generating a series of continuous, continuous slope, and continuous curvature
 * quintic splines. The splines are generated by the hardcoded math in {@link Segment}.
 * 
 * In order to follow the route, something I'm calling Team 3128's <i>Proprietary, Brute-Force Route-
 * Following Algorithm</i> (or the <i>PBFRFA</i>, pronounced "P buff-ruff-a"). It essenitally iterate through
 * the generated parametric splines in certain increments of the parameter s, hereby known as <i>parametric
 * incrememnts</i>, or <i>parincs</i>.
 * 
 * The PBFRFA uses some more math to figure out the farthest distance how far the robot can travel along
 * this path in a circular arc to arrive at another point on the route during the TrajectoryDuration
 * if traveling at a certain maximum velocity. It then passes the feed-forward velocity and distance travelled
 * by each side of the weelbase to the TalonSRXs to be followed.
 * 
 * The incredibly experimental and probably not going to work <i>Realtime PBFRFA(tm)</i> use the same Brute-Force
 * algorithm to generate the next point in the trajectory, but upon arrival at each of these points, the Realime 
 * PBFRFA generates a new spline with starting waypoint located at the estimated robot position calculated by
 * the {@link Odometer}, using that spline to produce the next {@link ProfilePoint}.
 * 
 * @author Ronak
 * 
 */
public class Routemaker {
    final public static int durationMs = 40;
    final public static double durationSec = durationMs / 1000.0;

    /**
     * How precise the iterator should be: parincs per meter
     */
    final private double RESOLUTION = 80;

    /**
     * The maximum number of degrees such that a sharp turn can be considered not a loop.
     */
    final private double ARBITRARY_LOOP_PROTECTION_BUFFER = 5.0;

    private Waypoint[] waypoints;

    private double[] parincs;
    private double[] lengths;

    private double l_sum = 0;
    private double r_sum = 0;

    private SRXTankDrive drive;

    private double v_max;
    private double wb;

    /**
     *
     * @param power - The maximum motor power during the motion.
     * @param waypoints - Array of target {@link Waypoint} objects.
     */
    public Routemaker(double power, Waypoint... waypoints) {
        this.waypoints = waypoints;

        drive = SRXTankDrive.getInstance();

        v_max = power * Convert.velocityCTREtoCMS(drive.robotMaxSpeed, drive.wheelCircumfrence);
        wb = drive.wheelBase;

        parincs = new double[waypoints.length - 1];
        lengths = new double[waypoints.length - 1];

        Segment segment;

        final double STEP = 0.05;

        for (int i = 0; i < waypoints.length - 1; i++) {
            segment = new Segment(waypoints[i], waypoints[i + 1]);
            double length = 0;

            for (double s = 0; s < 1.0; s += STEP) {
                length += RobotMath.distance(
                        segment.getX(s), segment.getY(s),
                        segment.getX(s + STEP), segment.getY(s + STEP));

            }

            parincs[i] = Length.m / (RESOLUTION * length);

            System.out.println(parincs[i]);
            lengths[i] = length;
        }

        ref_segment = 0;

        wp_target = waypoints[0];
        s = 0;
    }

    private int ref_segment;
    private Segment spline;

    // Positional information for the robot's center
    private double x_tp, y_tp, a_tp;

    private double x_l_tp, y_l_tp;
    private double x_r_tp, y_r_tp;

    private double x, y, a;
    private double x_l, y_l, x_r, y_r;
    private double da, d;

    public double dt;

    private double sin, rad;

    private double v_major, v_minor;
    private double v_l, v_r;

    private double r_l, r_r;

    public double s;

    private double v_cap;

    public Waypoint wp_target;

    private boolean last = false;

    public ProfilePoint getNextPoint(double speed) {
        return getNextPoint(wp_target.x, wp_target.y, wp_target.angle, speed);
    }

    /**
     *
     * @param x0 - The current x position of the robot, either determined through odometry or assumed from the last calculation.
     * @param y0 - The current y position of the robot, either determined through odometry or assumed from the last calculation.
     * @param a0 - The current heading of the robot, either determined through odometry or assumed from the last calculation.
     * @param speed - Fraction from 0.0 to 1.0, as to how much of maximum speed the robot should be travelling.
     * @return
     */
    public ProfilePoint getNextPoint(double x0, double y0, double a0, double speed) {
        x_tp = x0;
        y_tp = y0;
        a_tp = a0;

        // Generate a new Segment between the target of the previous profile point and the end waypoint of the segment
        if (s < 0.9)
            spline = new Segment(new Waypoint(wp_target, x_tp, y_tp, a_tp), waypoints[ref_segment + 1], s);

        // Figure out where the left and right wheelcenters ended up after the previous profile point
        x_l_tp = x_tp - (wb / 2) * RobotMath.cos(a_tp - 90);
        y_l_tp = y_tp - (wb / 2) * RobotMath.sin(a_tp - 90);

        x_r_tp = x_tp + (wb / 2) * RobotMath.cos(a_tp - 90);
        y_r_tp = y_tp + (wb / 2) * RobotMath.sin(a_tp - 90);

        dt = 0;

        v_cap = speed * v_max;

        while (dt < durationSec) {
            while (s <= 1) {
                s += parincs[ref_segment];

                x = spline.getX(s);
                y = spline.getY(s);
                a = spline.getAngle(s);

                da = a - a_tp;
                if (da > 360 - ARBITRARY_LOOP_PROTECTION_BUFFER) {
                    da = 360 - da;
                } else if (da < ARBITRARY_LOOP_PROTECTION_BUFFER - 360) {
                    da = 360 + da;
                }

                d = RobotMath.distance(x_tp, y_tp, x, y);
                sin = RobotMath.sin( Math.abs(da) / 2);
                rad = Math.abs(Math.toRadians(da));

                dt = rad * ((d / sin) + wb) / (2 * v_cap);

                if (dt > durationSec) {
                    break;
                }
            }

            if (dt < durationSec) {
                ref_segment++;
                s = 0;

                if (ref_segment == waypoints.length - 1) {
                    Waypoint lastPoint = waypoints[waypoints.length - 1];

                    s = 1.0;

                    x = lastPoint.x;
                    y = lastPoint.y;
                    y = lastPoint.angle;

                    last = true;

                    break;
                }
            }

        }

        v_major = Convert.velocityCMStoCTRE(v_cap, drive.wheelCircumfrence);
        v_minor = Convert.velocityCMStoCTRE(v_cap * (d - wb * sin)/(d + wb * sin), drive.wheelCircumfrence);

        x_l = x - (wb / 2) * RobotMath.cos(a - 90);
        y_l = y - (wb / 2) * RobotMath.sin(a - 90);

        x_r = x + (wb / 2) * RobotMath.cos(a - 90);
        y_r = y + (wb / 2) * RobotMath.sin(a - 90);

        if (da > 0) {
            v_l = v_minor;
            v_r = v_major;

            r_l = RobotMath.distance(x_l_tp, y_l_tp, x_l, y_l) / (2 * sin);
            r_r = r_l + wb;
        } else {
            v_l = v_major;
            v_r = v_minor;

            r_r = RobotMath.distance(x_r_tp, y_r_tp, x_r, y_r) / (2 * sin);
            r_l = r_r + wb;
        }

        l_sum += Convert.lengthCMtoCTRE(r_l * rad, drive.wheelCircumfrence);
        r_sum += Convert.lengthCMtoCTRE(r_r * rad, drive.wheelCircumfrence);

        wp_target = spline.getIntermediateWaypoint(s);

        return (new ProfilePoint(wp_target.x, wp_target.y, last, l_sum, r_sum, (last) ? 0 : v_l, (last) ? 0 : v_r, (int) Math.ceil(1000 * dt)));
    }
}